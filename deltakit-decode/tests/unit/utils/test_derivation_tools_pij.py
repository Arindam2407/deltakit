# (c) Copyright Riverlane 2020-2025.

import math
from pathlib import Path
from unittest import mock

import pytest
import stim
from deltakit_core.decoding_graphs import (dem_to_decoding_graph_and_logicals,
                                           dem_to_hypergraph_and_logicals)
from deltakit_core.data_formats import b8_to_syndromes
from deltakit_decode.utils import (calculate_pij_values,
                                   create_dem_from_pij,
                                   dem_and_pij_edges_max_diff,
                                   generate_expectation_data,
                                   parse_stim_circuit,
                                   pij_and_dem_edge_diff,
                                   pij_edges_max_diff,
                                   pijs_edge_diff)
from pytest_lazy_fixtures import lf


REFERENCE_DATA_DIR = Path(__file__).parent.parent.parent.parent.parent / "tests" / "reference_data"


class TestDerivationToolsPij:

    @pytest.fixture(scope="class")
    def stim_circuit(self, reference_data_dir: Path):
        return stim.Circuit.from_file(reference_data_dir / "stim" / "circuit_noisy.stim")

    @pytest.fixture(scope="class")
    def detection_events(self, reference_data_dir: Path):
        return reference_data_dir / "b801" / "detection_events.b8"

    @pytest.mark.parametrize(
        "circuit, samples, expected_pij_data",
        [
            [
                # below data generated from tests/reference_data/b801/detection_events.b8 using generate_expectation_data
                lf("stim_circuit"),
                list(b8_to_syndromes(REFERENCE_DATA_DIR / "b801" / "detection_events.b8", 24)),
                {(0,): 0.11757113971099674, (0, 1): 0.0034316065734057988, (0, 3): 0.02835564552651032,
                 (0, 4): -0.0007111227823917154, (0, 6): 0.0020678256907787906, (0, 7): 0.006137273719091452,
                 (1,): 0.0775168168855311, (1, 4): -5.975837756855285e-07, (1, 5): 0.005476689705997351,
                 (1, 7): 0.0031175919187231282, (2,): 0.10353096401496012, (2, 3): 0.031255381032578466,
                 (2, 6): 0.00889512209389759, (3,): 0.05370939402475062, (3, 6): 0.0003067368530239034,
                 (3, 7): -0.0001241144347825518, (4,): 0.04496493682998104, (4, 5): 0.03979002297602868,
                 (4, 7): 0.03437399135146213, (4, 8): 0.00042570886609066827, (4, 10): 0.002306783122669076,
                 (4, 11): 0.0013635753437751807, (5,): 0.07654526699496676, (5, 8): 0.030724759285900183,
                 (5, 9): 0.0026342023567060835, (5, 11): 0.0020725732825394583, (6,): 0.09330344655089358,
                 (6, 7): 0.0034249201188449874, (6, 10): 0.0025644793932262377, (7,): 0.08728292672703516,
                 (7, 10): 0.030658990160007227, (7, 11): 0.0007995936113563418, (8,): 0.08543214396783871,
                 (8, 9): 0.0042063460627758675, (8, 11): 0.02838865734990914, (8, 12): 0.0017114249773678702,
                 (8, 14): 0.00189590506377868, (8, 15): 0.007069802081343002, (9,): 0.07474330563624468,
                 (9, 12): -0.0007422418210834003, (9, 13): 0.005997403377222321, (9, 15): 0.0037595717206491686,
                 (10,): 0.07075834451660828, (10, 11): 0.03105824959771364,
                 (10, 14): 0.009624800524618116, (11,): 0.048025611236470346, (11, 14): 0.001442895289977042,
                 (11, 15): 0.0013309467893184435, (12,): 0.047000224862542773, (12, 13): 0.037730072835631956,
                 (12, 15): 0.03321410856639262, (12, 16): 0.0018111393425762623, (12, 18): 0.002419575717186484,
                 (12, 19): -8.886050158107839e-05, (13,): 0.07857056425513631, (13, 16): 0.030221312271721368,
                 (13, 17): 0.0023102049249105194, (13, 19): 0.001842753872066727, (14,): 0.09344784498976902,
                 (14, 15): 0.004333630404522892, (14, 18): 0.0010522829331826578, (15,): 0.08765497265510423,
                 (15, 18): 0.02732676694745967, (15, 19): 0.0017105648358720082, (16,): 0.08611172427871147,
                 (16, 17): 0.002799697486379593, (16, 19): 0.028940243506890118, (16, 20): 0.0018808335048869362,
                 (16, 22): 0.0025710995219347943, (16, 23): 0.008636756031773163, (17,): 0.0746454389700459,
                 (17, 20): 0.000378730590512133, (17, 21): 0.006021171736326214, (17, 23): 0.0038600240057299895,
                 (18,): 0.07728093896519349, (18, 19): 0.03107340593210084, (18, 22): 0.007003942622209436,
                 (19,): 0.04860759927183358, (19, 22): -0.001062018797428288, (19, 23): 0.0013279270419237488,
                 (20,): 0.04766111256221976, (20, 21): 0.03770418917451285, (20, 23): 0.03410075619673264,
                 (21,): 0.10840522019617281, (22,): 0.1005209867998681, (22, 23): 0.0028332468487208273,
                 (23,): 0.11115210469966132},
            ],
            [
                stim.Circuit(),
                list(),
                {}
            ],
        ]
    )
    def test_calculate_pij_values_calculates_correct_values(self, circuit, samples, expected_pij_data):
        graph, _, _ = parse_stim_circuit(circuit)
        exp_data = generate_expectation_data(samples, only_even=True)
        pij_data = dict(sorted(calculate_pij_values(
            exp_data, graph).items()))
        expected_pij_data = {frozenset(x): p for x, p in expected_pij_data.items()}
        for e, p in pij_data.items():
            assert math.isclose(p, expected_pij_data[e], rel_tol=0.0001)


    @pytest.mark.parametrize(
        "dem, exp_data",
        [
            [
                stim.DetectorErrorModel("\n".join(["error(0.01014648986783272221) D0",
                                                   "error(0.005729330378603070262) D0 D1",
                                                   "error(0.02018350684288267027) D0 D4",
                                                   "error(0.007182928284479361825) D0 D5",
                                                   "error(0.01058626812267576822) D0 D6",
                                                   "error(0.008573654079088943725) D1 D2",
                                                   "error(0.02034554214040479314) D1 D5",
                                                   "error(0.004778501009466806781) D1 D6",
                                                   "error(0.002649138598129596733) D1 D7",
                                                   "error(0.02135388514520309214) D1 L0",
                                                   "error(0.01350571239778072981) D2",
                                                   "error(0.006459147137450493847) D2 D3",
                                                   "error(0.03431879972334483941) D2 D6",
                                                   "error(0.01076033442525514694) D2 D7",
                                                   "error(0.02125835918007684677) D3 D7",
                                                   "error(0.006641647345162420002) D3 L0",
                                                   "error(0.03040857682084203636) D4",
                                                   "error(0.01140103431965433511) D4 D5",
                                                   "error(0.02210223628876822888) D5 D6",
                                                   "error(0.02491390055629894018) D5 L0",
                                                   "error(0.03250834302383964758) D6",
                                                   "error(0.01627602033562725037) D6 D7",
                                                   "error(0.02838249442493352356) D7 L0",
                                                   "detector(1, 4, 0) D0",
                                                   "detector(3, 4, 0) D1",
                                                   "detector(3, 6, 0) D2",
                                                   "detector(5, 6, 0) D3",
                                                   "detector(1, 4, 1) D4",
                                                   "detector(3, 4, 1) D5",
                                                   "detector(3, 6, 1) D6",
                                                   "detector(5, 6, 1) D7"])),
                {(5,): 0.08044, (6,): 0.10968, (5, 6): 0.02432, (2,): 0.06988, (2, 6): 0.03332, (3,): 0.03372, (2, 3): 0.00764, (0,): 0.05168, (1,): 0.06048, (7,): 0.0748, (6, 7): 0.01956, (4,): 0.05964, (0, 4): 0.02004, (1, 6): 0.00996, (1, 2): 0.01088, (2, 7): 0.01336, (0, 6): 0.01332, (4, 5): 0.01352,
                 (4, 6): 0.0082, (3, 7): 0.02052, (0, 2): 0.00428, (2, 4): 0.00424, (3, 4): 0.00248, (4, 7): 0.0048, (1, 5): 0.02084, (2, 5): 0.00632, (3, 6): 0.00384, (3, 5): 0.0024, (0, 5): 0.00968, (0, 1): 0.00772, (1, 4): 0.0046, (1, 7): 0.00652, (0, 7): 0.00392, (0, 3): 0.0014, (5, 7): 0.00528, (1, 3): 0.00176},
            ]
        ]
    )
    def test_calculate_pij_values_calculates_correct_values_from_dem(self, dem, exp_data):
        graph, _ = dem_to_decoding_graph_and_logicals(dem)
        exp_data = {frozenset(x): p for x, p in exp_data.items()}
        pij_data = calculate_pij_values(exp_data, graph)
        for e in graph.edges:
            assert math.isclose(
                graph.edge_records[e].p_err, pij_data[e.vertices - graph.boundaries], rel_tol=0.00017)

    @pytest.mark.parametrize(
        "circuit, b8_path, exp_pij",
        [
            [
                lf("stim_circuit"),
                lf("detection_events"),
                {(0, 2): 0.008487142595907365, (0, 2, 8): 0.0057179733491601326, (0, 3): 0.00499541137093551, (0, 5): 0.016035316401670906, (0, 5, 7): 0.0024960377211428186, (0, 5, 8): 0.003427731752330687, (0, 7, 8): 0.0039406594899650815, (0, 7, 9): 0.0014099700259687098, (0, 7, 10): 0.001410450034731725, (0, 7): 0.0018857810023561875, (0, 8, 9): 0.000510374916962486, (0, 8, 10): 0.003865287739301171, (0, 8): -0.004507447398038322, (0, 9): 0.002198538898094405, (0, 10): 0.0026740599514824075, (0,): 0.016354969254952906, (1, 3): 0.008700195592032944, (1, 9): 0.019721520589369435, (1,): 0.0044938050894097106, (2,): 0.005564617116315536, (2, 5): 0.0028221530029423412, (2, 5, 8): 0.00228264357023078, (2, 6): 0.02562041267258687, (2, 6, 8): 0.0034398687609591416, (2, 8): 0.0012837763261494904, (2, 8, 10): 0.0035092494095398385, (2, 10): 0.002782148926567891, (3,): 0.012518099409281586, (3, 9): 0.004112660270349559, (3, 9, 11): 0.00047546035842221945, (3, 10): 0.019096987123321266, (3, 10, 11): 0.0029812984005785914, (3, 11): 0.006572936670459468, (4,): 0.022395010916623888, (4, 5, 6): 0.0013702801777890072, (4, 5, 7): 0.020668104751670857, (4, 5, 13): 0.006795734604012893, (4, 5, 15): 0.005849934139096125, (4, 5, 16): 0.0010434490381171502, (4, 5): 0.014129708142545418, (4, 6, 13): -0.0003425488225794471, (4, 7): 0.01926020014052797, (4, 12): 0.021040791490055742, (4, 12, 13): 0.003009159668836414, (4, 13, 15): 0.0027650750541015068, (4, 13, 16): 0.002097500792436313, (4, 13): 0.000478641043753592, (4, 15): 0.008008553809973533, (4, 16): 0.0017645887839742053, (5, 6): 0.0002861887818635156, (5, 6, 8): 0.01942101674294494, (5, 6, 16): 0.0077234030030362, (5, 7, 8): 0.015813800504273, (5, 7, 15): 0.004264143081429916, (5, 7, 17): 0.0032558512232997994, (5, 7): -0.0011289974806490983, (5, 8): -0.0022263078626142785, (5, 10): 0.026362510815445772, (5, 13): 0.016032375170642255, (5, 13, 16): 0.005157936517378003, (5, 15, 16): 0.004138865839704686, (5, 15, 17): 0.0021602163999829838, (5, 15): -0.003312206912214917, (5, 17): 0.0005031368126485052, (5, 18): 0.009100552577541776, (5,): 0.0029109268765809566, (6,): 0.023272940639790532, (6, 8): 0.005848014718247867, (6, 8, 16): 0.009728978434325686, (6, 8, 18): 0.004781961747057362, (6, 13): 0.002639631558635194, (6, 13, 16): 0.0025160496971646795, (6, 14): 0.026800314240871575, (6, 14, 16): 0.0019849922798497177, (6, 16): -0.007582834936955392, (6, 16, 18): 0.0017767447453796437, (6, 18): -0.0004994691463810081, (7,): 0.038025741106843286, (7, 8): -0.01487320388515523, (7, 8, 10): 0.016199963752276836, (7, 8, 18): 0.004332075408395308, (7, 9, 10): 0.012998663157783363, (7, 9, 17): 0.0032489704233245043, (7, 9): 0.02035455332410406, (7, 10, 17): 0.0031038767423638425, (7, 10, 18): 0.0041585628739216896, (7, 10, 19): 0.001268195448271836, (7, 15): 0.014710432530887944, (7, 15, 17): 0.005100935814676966, (7, 16): 0.005576563223609776, (7, 17, 18): 0.004622918926573849, (7, 17): -0.005056609648872386, (7, 18, 19): 0.0014420573000734072, (7, 19): 0.0010373377045834059, (8,): 0.048884415025510684, (8, 9, 10): 0.0011575411951774695, (8, 10): -0.0008413130561390578, (8, 10, 11): 0.018437167826799883, (8, 10, 19): 0.003290805959633214, (8, 11): 0.015664255497025374, (8, 16): 0.017078107422462713, (8, 16, 18): 0.004322627173829696, (8, 18): -0.001462606643530338, (8, 18, 19): 0.005753684040615492, (8, 19): 0.002798897160159019, (9, 10): 0.007390920632845894, (9, 10, 11): 0.0007324799652356218, (9, 17): 0.021197828128575687, (9,): 0.012674885132114247, (10,): -0.0005015137971162406, (10, 11): 0.015414619876456627, (10, 11, 19): 0.002405576813975241, (10, 17): 0.0045171709614344885, (10, 17, 19): 0.0005145338165132851, (10, 18): 0.018101623651593707, (10, 18, 19): 0.003695866473860998, (10, 19): 0.00018692203480862946, (11,): 0.039368297209590626, (11, 19): 0.024709010054965154, (12,): 0.008548437789919172, (12, 13, 14): 0.00021295273528193492, (12, 13, 15): 0.019770053158097267, (12, 13, 21): 0.004597049883482585, (12, 13, 23): 0.006333558034733844, (12, 13, 24): 0.003978027933825401, (12, 13): 0.011621465674499391, (12, 14, 21): 0.0005659279618348001, (12, 15): 0.018318723836287427, (12, 20): 0.0215962508673928, (12, 20, 21): 0.0008981619641014182, (12, 21, 23): 0.0038934424108336696, (12, 21, 24): 0.0030916538359831436, (12, 21): -0.0003658292386366412, (12, 23): 0.007330939269443864, (12, 24): -0.002120428020541244, (13, 14): 0.0036754888684070344, (13, 14, 16): 0.017047006875156534, (13, 14, 24): 0.0074276693262042, (13, 15, 16): 0.014472281047562485, (13, 15, 23): 0.004309726980179895, (13, 15, 25): 0.0027179652023267553, (13, 15): -0.0011338122083709202, (13, 18): 0.024208496297572546, (13, 21): 0.01540288682727113, (13, 21, 24): 0.004550330788894441, (13, 23, 24): 0.004265525026092953, (13, 23, 25): 0.0023706407266238516, (13, 23): -0.0031042476757984602, (13, 25): -0.0014108474323031193, (13, 26): 0.008258087634587796, (13,): -0.002959241115453781, (14,): 0.021240540154607666, (14, 16): 0.008460258346766341, (14, 16, 24): 0.008101188518295388, (14, 16, 26): 0.0032605557994004886, (14, 21): 0.0008454291643376297, (14, 21, 24): 0.0028103069574218487, (14, 22): 0.029682948853720536,
                 (14, 22, 24): 0.004630180930355221, (14, 24): -0.007022563236756582, (14, 24, 26): 0.002590405782707028, (14, 26): 4.4610171767173816e-05, (15,): 0.00811442477680873, (15, 16): -0.01026043988788063, (15, 16, 18): 0.014597813570301599, (15, 16, 26): 0.00341636771147269, (15, 17, 18): 0.014652388129945848, (15, 17, 25): 0.004326208796880782, (15, 17): 0.01136993676378027, (15, 18, 25): 0.004156570132497428, (15, 18, 26): 0.005393010779809249, (15, 18, 27): 0.0014623666905737576, (15, 23): 0.015065979289026525, (15, 23, 25): 0.005151477049232911, (15, 24): 0.006058942901372377, (15, 25, 26): 0.0058773765359110275, (15, 25): -0.007457940483921968, (15, 26, 27): 0.0029517704561843328, (15, 27): 0.0007461675540028199, (16,): 0.0068744058768685995, (16, 18): 0.0024620087123892213, (16, 18, 19): 0.019089077517649433, (16, 18, 27): 0.002399853851303313, (16, 19): 0.01688876181342111, (16, 24): 0.020725057928599924, (16, 24, 26): 0.0047156253446956065, (16, 26): 0.0002154966306926029, (16, 26, 27): 0.004428953629893484, (16, 27): 0.0026728125115638313, (17, 18): 0.005080808753599544, (17, 18, 19): 0.0015139682682192013, (17, 25): 0.022197872840606606, (17,): 0.01090429812467849, (18,): -0.011895279810869758, (18, 19): 0.008712241314250847, (18, 19, 27): 0.002309046404031012, (18, 25): 0.004157269721221736, (18, 25, 27): 0.0011047551841222858, (18, 26): 0.015900851837021675, (18, 26, 27): 0.003005166877476262, (18, 27): 0.0017019347280903413, (19,): 0.01740453950890081, (19, 27): 0.022437017134160908, (20,): 0.004018151850240777, (20, 21, 22): 0.0008425279966302601, (20, 21, 23): 0.020729072916044977, (20, 21, 29): 0.004330909763888391, (20, 21, 31): 0.004895677416937416, (20, 21, 32): 0.0021611430414604227, (20, 21): 0.014900968671510815, (20, 22, 29): 0.0008611900236932812, (20, 23): 0.01933694034403736, (20, 28): 0.020544925646679736, (20, 28, 29): 0.0026134833002194324, (20, 29, 31): 0.0025265051466844546, (20, 29, 32): 0.002579062004840149, (20, 29): 0.0008701998888047279, (20, 31): 0.008087971702372094, (20, 32): -0.0008880475661894132, (21, 22): 0.002685776871257275, (21, 22, 24): 0.01779564383742066, (21, 22, 32): 0.007392292149305979, (21, 23, 24): 0.016381209744286807, (21, 23, 31): 0.00373309991880022, (21, 23, 33): 0.002585627159470527, (21, 23): -0.001271428623106727, (21, 26): 0.02471904660774482, (21, 29): 0.01881222809044089, (21, 29, 32): 0.003532457082407181, (21, 31, 32): 0.003566745506350666, (21, 31, 33): 0.001932043120384197, (21, 31): -0.0006345891005620692, (21, 33): 0.0007402656633283642, (21, 34): 0.011725612770647875, (21,): -0.011636571515742959, (22,): 0.019870195788400394, (22, 24): 0.006167448735796439, (22, 24, 32): 0.01006444636752718, (22, 24, 34): 0.004393904712465757, (22, 29): 0.0026433606167506306, (22, 29, 32): 0.0023122685244813534, (22, 30): 0.026494641985919932, (22, 30, 32): 0.005001541461786052, (22, 32): -0.008464310792368817, (22, 32, 34): 0.0035847290235178075, (22, 34): -0.0016171377478662638, (23,): 0.0034032256446271197, (23, 24): -0.011938122023229948, (23, 24, 26): 0.015758112903261345, (23, 24, 34): 0.004732179943809145, (23, 25, 26): 0.016282179738921765, (23, 25, 33): 0.005152778831841454, (23, 25): 0.00889053738649498, (23, 26, 33): 0.005271843455988412, (23, 26, 34): 0.005054915420720507, (23, 26, 35): 0.001579194130130801, (23, 31): 0.018689822235487024, (23, 31, 33): 0.005614955747142769, (23, 32): 0.007242186449054111, (23, 33, 34): 0.007227214146014571, (23, 33): -0.008021272155641041, (23, 34, 35): 0.002809749056179589, (23, 35): 0.0004388246757009193, (24,): 0.004925094866121378, (24, 26): 7.126052242410379e-05, (24, 26, 27): 0.018886050572057778, (24, 26, 35): 0.0030032551870781687, (24, 27): 0.01810098628539853, (24, 32): 0.01596335411974, (24, 32, 34): 0.007231548469775528, (24, 34): -0.0038400793151485966, (24, 34, 35): 0.0042838964471751395, (24, 35): 0.0033250274273497657, (25, 26): 0.0025132186371741145, (25, 26, 27): 0.0011089149377768726, (25, 33): 0.020570013665074452, (25,): 0.016782217163708583, (26,): -0.011946811984413974, (26, 27): 0.0090809490506754, (26, 27, 35): 0.002075546740224199, (26, 33): 0.0024897068771822907, (26, 33, 35): 0.0008725387584028743, (26, 34): 0.019523980144781426, (26, 34, 35): 0.0032966950863627664, (26, 35): -0.00031806021601057206, (27,): 0.014037950296313367, (27, 35): 0.024991016466527616, (28,): 0.03080874812206738, (28, 29, 30): 0.0005070117310920219, (28, 29, 31): 0.01908944717922717, (28, 29, 36): 0.006926682127929629, (28, 29): 0.02092060247221886, (28, 30, 36): 0.00027327053546727376, (28, 31): 0.02121569467169851, (28, 36): 0.008950331643835215, (29, 30): 0.008619730511067078, (29, 30, 31): 0.0009106701540118056, (29, 30, 32): 0.019287857001279773, (29, 31, 32): 0.0163998372577559, (29, 31, 37): 0.0006642936987201753, (29, 31, 39): 0.003803652952180381, (29, 31): 0.0004904385927255237, (29, 32, 39): 0.0026666531760446976, (29, 34): 0.02689279807814493, (29, 36): 0.0191787282691738, (29, 37): 0.0021071882055372234, (29, 39): 0.0016628154743148205, (29,): -0.0033429146862665672, (30,): 0.01577713510879238, (30, 31, 39): 0.0007562624153080177, (30, 32): 0.01668320583913783, (30, 32, 39): 0.0034458982359216184, (30, 36): 0.0032903744567950007, (30, 38): 0.03154660085599609, (30, 39): 0.0011265594720851174, (31,): 0.03768024713725944, (31, 32): -0.014115339560317847, (31, 32, 34): 0.016587724974603035, (31, 32, 39): 0.004361439960160196, (31, 33, 34): 0.013498869036682015, (31, 33, 37): 0.0048317743817453684, (31, 33): 0.011418079767176173, (31, 34): -0.005675320521642186, (31, 34, 37): 0.005898932053247874, (31, 34, 39): 0.006731118484698262, (31, 37, 39): 0.003482104167921829, (31, 37): -0.0003115124324298341, (31, 39): -0.0039067468153062305, (32,): 0.035864673384996576, (32, 34): -0.0012855074663645975, (32, 34, 35): 0.016614693214418386, (32, 34, 39): 0.004479976757516602, (32, 35): 0.01700757541785484, (32, 39): -3.9136297781559217e-05, (33, 34): 0.003507225037620568, (33, 34, 35): 0.0015156730431926113, (33, 37): 0.02178710890915765, (33,): 0.015598446961482625, (34,): -0.008343932399305237, (34, 35): 0.013467204070752586, (34, 37): 0.003985243766515373, (34, 39): 0.017270044135193865, (35,): 0.03777765672970262, (36, 38): 0.021935572850543927, (36, 39): 0.013179880796173327, (36,): 0.02820308685866488, (37, 39): 0.014043644946835378, (37,): 0.02176305436204884, (38,): 0.013888994739207435, (39,): 0.035292540269184006}
            ]
        ]
    )
    def test_calculate_pij_values_calculates_correct_degree_3_hypergraph(self, circuit, b8_path, exp_pij):
        dem = circuit.detector_error_model()
        hyper_graph, _ = dem_to_hypergraph_and_logicals(dem)
        samples = list(b8_to_syndromes(b8_path, len(hyper_graph.nodes)))
        exp_data = generate_expectation_data(samples, max_degree=3)
        pij_values = calculate_pij_values(exp_data, hyper_graph, max_degree=3)
        exp_pij = {frozenset(x): p for x, p in exp_pij.items()}
        for e, p in pij_values.items():
            assert math.isclose(p, exp_pij[e], rel_tol=0.0001)

    def test_calculate_pij_values_only_considers_edges_up_to_max_degree_even_if_graph_higher_degree(self, stim_circuit: stim.Circuit, detection_events):
        dem = stim_circuit.detector_error_model()
        hyper_graph, _ = dem_to_hypergraph_and_logicals(dem)
        samples = list(b8_to_syndromes(detection_events, len(hyper_graph.nodes)))
        exp_data = generate_expectation_data(samples, max_degree=3)
        pij_values = calculate_pij_values(exp_data, hyper_graph, max_degree=2)
        w2_count = 0
        for e in hyper_graph.edges:
            if len(e) <= 2:
                w2_count += 1
        assert len(pij_values) == w2_count

    @pytest.mark.parametrize(
        "dem, exp_data",
        [
            [
                stim.DetectorErrorModel("\n".join([
                    "error(0.6) D0",
                    "error(0.6) D1",
                    "error(0.6) D2",
                    "error(0.6) D3",
                    "error(0.6) D4",
                    "error(0.6) D0 D1",
                    "error(0.6) D0 D2",
                    "error(0.6) D0 D3",
                    "error(0.6) D0 D4",
                    "error(0.6) D0 D1 D2",
                    "error(0.6) D0 D1 D3",
                    "error(0.6) D0 D1 D4",
                    "error(0.6) D0 D2 D3",
                    "error(0.6) D0 D2 D4",
                    "error(0.6) D0 D3 D4",
                    "error(0.6) D0 D1 D2 D3",
                    "error(0.6) D0 D1 D2 D4",
                    "error(0.6) D0 D2 D3 D4",
                    "detector(1, 0, 0) D0",
                    "detector(2, 0, 0) D1",
                    "detector(3, 0, 0) D2",
                    "detector(4, 0, 0) D3",
                    "detector(5, 0, 0) D4"])),
                {(0,): 1e-05, (1,): 0.01, (2,): 0.01, (3,): 0.01, (4,): 0.01, (0, 1): 200.1,
                 (0, 2): 200.5, (0, 3): 200.5, (0, 4): 200.5, (0, 1, 2): 1.4, (0, 1, 3): 1.0,
                 (0, 1, 4): 1.0, (0, 2, 3): 1.0, (0, 2, 4): 1.0, (0, 3, 4): 1.0, (0, 1, 2, 3): 1.0,
                 (0, 1, 2, 4): 1.0, (0, 2, 3, 4): 1.0},
            ],
        ]
    )
    def test_calculate_pij_values_warns_if_too_many_edges_leads_to_pi_sigma_convergence(self, dem, exp_data):
        exp_data = {frozenset(x): p for x, p in exp_data.items()}
        hyper_graph, _ = dem_to_hypergraph_and_logicals(dem)
        with pytest.warns(UserWarning, match=r"pi_sigma is converging to 0.5. Please consider trimming the number of edges used in calculations."):
            calculate_pij_values(exp_data, hyper_graph, max_degree=4)

    def test_calculate_pij_values_ignores_degree_4_edges_when_calculating_degree_3_hypergraph(self, stim_circuit: stim.Circuit, detection_events):
        dem = stim_circuit.detector_error_model()
        hyper_graph, _ = dem_to_hypergraph_and_logicals(dem)
        samples = list(b8_to_syndromes(detection_events, len(hyper_graph.nodes)))
        exp_data = generate_expectation_data(samples, max_degree=3)
        pij_values = calculate_pij_values(exp_data, hyper_graph, max_degree=3)
        w4_count = 0
        for e in hyper_graph.edges:
            if len(e) == 4:
                w4_count += 1
        assert len(pij_values) == len(hyper_graph.edges)-w4_count

    def test_calculate_pij_values_when_max_degree_4_then_pij_matches_stim_graph(self, stim_circuit: stim.Circuit, detection_events):
        dem = stim_circuit.detector_error_model()
        hyper_graph, _ = dem_to_hypergraph_and_logicals(dem)
        samples = list(b8_to_syndromes(detection_events, len(hyper_graph.nodes)))
        exp_data = generate_expectation_data(samples, max_degree=4)
        pij_values = calculate_pij_values(exp_data, hyper_graph, max_degree=4)
        assert len(pij_values) == len(hyper_graph.edges)

    @pytest.mark.parametrize(
        "expectation_data, expected_edges",
        [
            [
                {(0,): 0.4, (0, 1): 0.2, (0, 2): 0.01, (0, 3): 0.005, (1,): 0.04,
                 (1, 2): 0.01, (1, 3): 0.3, (2,): 0.05, (2, 3): 0.2, (3,): 0.0001},
                [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3),
                 (2, 3), (0,), (1,), (2,), (3,)],
            ],
            [
                {(0,): 0.4, (0, 1): 0.2, (1,): 0.04,},
                [(0, 1), (0,), (1,),],
            ],
        ]
    )
    def test_calculate_pij_values_returns_all_edges_if_no_graph_given(self, expectation_data, expected_edges):
        expectation_data = {frozenset(x): p for x, p in expectation_data.items()}
        expected_edges = [frozenset(x) for x in expected_edges]
        pij_data = calculate_pij_values(expectation_data)
        assert set(expected_edges) == set(pij_data.keys())

    # UserWarning occurs when circuit has no noise
    @pytest.mark.filterwarnings("ignore:Isolated logical observables:UserWarning")
    @pytest.mark.parametrize(
        "pij_data, circuit, expected_dem, trim_circuit",
        [
            [
                {(4, 5): 0.03790345231176562, (5, 9): 0.002868529500751227, (19, 22): 0.00026461800103988464, (0, 7): 0.005653928489673998, (20, 21): 0.03732508255785305, (20, 23): 0.03377131332412736, (10, 14): 0.008048770793723514, (13, 16): 0.029471609130065857, (0, 4): 5.837840850303477e-05, (16, 19): 0.02849572252441407, (4, 7): 0.03391940293960499, (6, 7): 0.0025136844937678204, (5, 8): 0.030405150326564157, (5, 11): 0.0017414746364182165, (8, 11): 0.027984373755002068, (0, 6): 0.0021703933982749612, (2, 6): 0.008650733655094611, (10, 11): 0.031957510864608796, (16, 17): 0.0034586936869899776, (16, 23): 0.008068947959818884, (17, 21): 0.006330654381463907, (17, 23): 0.00435744864841936, (0, 3): 0.029459473033565553, (2, 3): 0.032492004339083114, (19, 23): 0.0012011471472747615, (15, 18): 0.0266316292986451, (12, 13): 0.03852901555238519, (12, 16): 0.002805042152225601, (9, 15): 0.004175763292184775, (7, 10): 0.02996865757262679, (4, 10): 0.0023681689647790383, (8, 14): 0.002172693153775329, (14, 18): 0.00212595310063618, (16, 20): 0.0021191286955135613, (12, 19): 0.0006605574154216476, (1, 7): 0.0029128413532241715, (9, 12): 6.645559185447514e-06, (18, 19): 0.03166821612240017, (1, 5): 0.006304565824739483, (8, 15): 0.007929363945550938, (1, 4): 0.0002694083680992998, (3, 7): 0.0001230841508201852, (0, 1): 0.0033969500102377093,
                 (18, 22): 0.007292298572883826, (12, 15): 0.032676486586826314, (3, 6): 3.130775328430424e-07, (6, 10): 0.001876040683835789, (8, 9): 0.0044617889726719095, (13, 17): 0.002332912100089124, (14, 15): 0.003335912259372853, (4, 8): 0.0015633121920086701, (22, 23): 0.003070810256326939, (7, 11): 0.0008974611451682546, (11, 15): 0.0009482626326038912, (15, 19): 0.0020530644693578237, (11, 14): 0.0010592278973130531, (16, 22): 0.002235768312187414, (17, 20): 0.00016621900521496258, (9, 13): 0.006808681993422827, (12, 18): 0.001967333588214215, (8, 12): 0.0012918472336771458, (13, 19): 0.0011708642415981796, (4, 11): 0.001051769393903057, (4,): 0.04551550723348229, (5,): 0.07559024781243702, (9,): 0.073647168255709, (2,): 0.10392065331006212, (19,): 0.0475047568480284, (22,): 0.0977406913084846, (6,): 0.0952234148782009, (21,): 0.10905870200243195, (0,): 0.1174505966134559, (7,): 0.08997803071302188, (20,): 0.04800572942775009, (23,): 0.11106620112455949, (10,): 0.07287127904108855, (13,): 0.07849661480645605, (14,): 0.09386030132845684, (16,): 0.08430965094219844, (18,): 0.07574656757873897, (8,): 0.08651894856083293, (11,): 0.049722477154960955, (1,): 0.07739937962679226, (3,): 0.05251452846159589, (17,): 0.0743670462989586, (15,): 0.08694066417869489, (12,): 0.045744965556093246},                lf("stim_circuit"),
                stim.DetectorErrorModel.from_file(
                    REFERENCE_DATA_DIR / "dem" / "circuit_noisy.dem"),
                True,
            ],
            [
                {(0, 1): 0.0033969500102377093, (0, 3): 0.029459473033565553, (0, 6): 0.0021703933982749612, (1, 2): 0.020344412409301516, (1, 4): 0.0002694083680992998, (1, 6): 0.0006378761874903938, (1, 7): 0.0029128413532241715, (3, 4): 0.0, (3, 6): 3.130775328430424e-07, (3, 7): 0.0001230841508201852, (3, 9): 0.0006057086936336886, (6, 7): 0.0025136844937678204, (6, 9): 0.0009587468112532971, (6, 12): 0.0003327594949091295, (2, 5): 0.0031492608745825046, (2, 7): 0.009651464977080304, (2, 8): 0.005662074136275064, (4, 5): 0.03790345231176562, (4, 7): 0.03391940293960499, (4, 8): 0.0015633121920086701, (4, 9): 0.001542441871037581, (4, 10): 0.0023681689647790383, (7, 8): 0.021171477898419833, (7, 10): 0.02996865757262679, (7, 12): 0.0005492460100288699, (7, 13): 0.0043138540973308714, (5, 8): 0.030405150326564157, (5, 10): 0.02068417785682586, (5, 11): 0.0017414746364182165, (8, 11): 0.027984373755002068, (8, 13): 0.0069478685353558944, (8, 14): 0.002172693153775329, (9, 10): 0.02012836539658236, (9, 12): 6.645559185447514e-06, (9, 13): 0.006808681993422827, (9, 15): 0.004175763292184775, (10, 11): 0.031957510864608796, (10, 13): 0.005008004286473744, (10, 14): 0.008048770793723514, (10, 15): 0.00987225373110695, (10, 16): 0.004213254628679164, (11, 14): 0.0010592278973130531, (11, 16): 0.0008867563214751129, (11, 17): 0.0015846503686640645, (12, 13): 0.03852901555238519, (12, 15): 0.032676486586826314, (12, 18): 0.001967333588214215,
                 (13, 14): 0.023268257088124134, (13, 16): 0.029471609130065857, (13, 18): 0.02034474697968225, (13, 19): 0.0011708642415981796, (14, 17): 0.0016035239988345662, (14, 19): 0.0024519317961135823, (14, 20): 0.0008923892257873822, (15, 16): 0.02213965916097249, (15, 18): 0.0266316292986451, (15, 19): 0.0020530644693578237, (15, 21): 0.00601501808674304, (16, 17): 0.0034586936869899776, (16, 19): 0.02849572252441407, (16, 20): 0.0021191286955135613, (16, 21): 0.007661596419992145, (16, 22): 0.002235768312187414, (17, 20): 0.00016621900521496258, (17, 22): 0.00010419601797651001, (17, 23): 0.00435744864841936, (18, 19): 0.03166821612240017, (18, 21): 0.00389159492429636, (19, 20): 0.0, (19, 22): 0.00026461800103988464, (20, 23): 0.03377131332412736, (21, 22): 0.02348579272760426, (22, 23): 0.003070810256326939, (0,): 0.12182057073690612, (1,): 0.06447394749717668, (2,): 0.1062529626494346, (3,): 0.08108644906803997, (4,): 0.045121237433445635, (5,): 0.06261083887100376, (6,): 0.10218586841480205, (7,): 0.06490543912061458, (8,): 0.06916607375568737, (9,): 0.05952194205035223, (10,): 0.01935215168049774, (11,): 0.05010558787103038, (12,): 0.049260881743419686, (13,): 0.02606483681374181, (14,): 0.07448053840904681, (15,): 0.06456413270128943, (16,): 0.06340154341059719, (17,): 0.07894922864013322, (18,): 0.06265072250595685, (19,): 0.046966531345432785, (20,): 0.08099935303141628, (21,): 0.11173005115356242, (22,): 0.0839839243646015, (23,): 0.1182620295605309},
                stim.Circuit.from_file(REFERENCE_DATA_DIR / "stim" /
                                       "circuit_logical_off_boundary.stim"),
                stim.DetectorErrorModel.from_file(
                    REFERENCE_DATA_DIR / "dem" / "circuit_logical_off_boundary.dem"),
                True,
            ],
            [
                {(3, 7): 0.005125248374863278, (0, 4): 0.0057317127591073325, (4,): 0.0057317127591073125, (7,): 0.005125248374863215},
                stim.Circuit.from_file(REFERENCE_DATA_DIR / "stim" /
                                       "unobservable_logical_rotated_mem_z_d3_r3.stim"),
                stim.DetectorErrorModel.from_file(
                    REFERENCE_DATA_DIR / "dem" / "unobservable_logical_rotated_mem_z_d3_r3.dem"),
                False,
            ],
            [
                {(4, 5): 0.03790345231176562, (5, 9): 0.002868529500751227, (19, 22): 0.00026461800103988464, (0, 7): 0.005653928489673998, (20, 21): 0.03732508255785305, (20, 23): 0.03377131332412736, (10, 14): 0.008048770793723514, (13, 16): 0.029471609130065857, (0, 4): 5.837840850303477e-05, (16, 19): 0.02849572252441407, (4, 7): 0.03391940293960499, (6, 7): 0.0025136844937678204, (5, 8): 0.030405150326564157, (5, 11): 0.0017414746364182165, (8, 11): 0.027984373755002068, (0, 6): 0.0021703933982749612, (2, 6): 0.008650733655094611, (10, 11): 0.031957510864608796, (16, 17): 0.0034586936869899776, (16, 23): 0.008068947959818884, (17, 21): 0.006330654381463907, (17, 23): 0.00435744864841936, (0, 3): 0.029459473033565553, (2, 3): 0.032492004339083114, (19, 23): 0.0012011471472747615, (15, 18): 0.0266316292986451, (12, 13): 0.03852901555238519, (12, 16): 0.002805042152225601, (9, 15): 0.004175763292184775, (7, 10): 0.02996865757262679, (4, 10): 0.0023681689647790383, (8, 14): 0.002172693153775329, (14, 18): 0.00212595310063618, (16, 20): 0.0021191286955135613, (12, 19): 0.0006605574154216476, (1, 7): 0.0029128413532241715, (9, 12): 6.645559185447514e-06, (18, 19): 0.03166821612240017, (1, 5): 0.006304565824739483, (8, 15): 0.007929363945550938, (1, 4): 0.0002694083680992998, (3, 7): 0.0001230841508201852, (0, 1): 0.0033969500102377093,
                 (18, 22): 0.007292298572883826, (12, 15): 0.032676486586826314, (3, 6): 3.130775328430424e-07, (6, 10): 0.001876040683835789, (8, 9): 0.0044617889726719095, (13, 17): 0.002332912100089124, (14, 15): 0.003335912259372853, (4, 8): 0.0015633121920086701, (22, 23): 0.003070810256326939, (7, 11): 0.0008974611451682546, (11, 15): 0.0009482626326038912, (15, 19): 0.0020530644693578237, (11, 14): 0.0010592278973130531, (16, 22): 0.002235768312187414, (17, 20): 0.00016621900521496258, (9, 13): 0.006808681993422827, (12, 18): 0.001967333588214215, (8, 12): 0.0012918472336771458, (13, 19): 0.0011708642415981796, (4, 11): 0.001051769393903057, (4,): 0.04551550723348229, (5,): 0.07559024781243702, (9,): 0.073647168255709, (2,): 0.10392065331006212, (19,): 0.0475047568480284, (22,): 0.0977406913084846, (6,): 0.0952234148782009, (21,): 0.10905870200243195, (0,): 0.1174505966134559, (7,): 0.08997803071302188, (20,): 0.04800572942775009, (23,): 0.11106620112455949, (10,): 0.07287127904108855, (13,): 0.07849661480645605, (14,): 0.09386030132845684, (16,): 0.08430965094219844, (18,): 0.07574656757873897, (8,): 0.08651894856083293, (11,): 0.049722477154960955, (1,): 0.07739937962679226, (3,): 0.05251452846159589, (17,): 0.0743670462989586, (15,): 0.08694066417869489, (12,): 0.045744965556093246},
                stim.Circuit.from_file(REFERENCE_DATA_DIR / "stim" /
                                       "circuit_noisy_2_observables.stim"),
                stim.DetectorErrorModel.from_file(
                    REFERENCE_DATA_DIR / "dem" / "circuit_noisy_2_observables.dem"),
                True,
            ],
        ]
    )
    def test_create_dem_from_pij_creates_correct_dem_from_stim(self, pij_data, circuit, expected_dem, trim_circuit):
        pij_data = {frozenset(x): p for x, p in pij_data.items()}
        graph, logicals, _ = parse_stim_circuit(
            circuit, trim_circuit=trim_circuit)
        dem = create_dem_from_pij(pij_data, graph, logicals)
        assert set(dem) == set(expected_dem)

    @pytest.mark.parametrize(
        "dem, pij_data",
        [
            [
                stim.DetectorErrorModel("\n".join([
                    "error(0.5) D0 D1 D2",
                    "detector(1, 0, 0) D0",
                    "detector(2, 0, 0) D1",
                    "detector(3, 0, 0) D2",
                ])),
                {(0, 1, 2): 0.5}
            ],
            [
                stim.DetectorErrorModel("\n".join([
                    "error(0.5) D0 D1 D2 D3",
                    "detector(1, 0, 0) D0",
                    "detector(2, 0, 0) D1",
                    "detector(3, 0, 0) D2",
                    "detector(4, 0, 0) D3",
                ])),
                {(0, 1, 2, 3): 0.5}
            ],
            [
                stim.DetectorErrorModel("\n".join([
                    "error(0.5) D0 D1 D2",
                    "error(0.5) D0 D1 D2 D3",
                    "detector(1, 0, 0) D0",
                    "detector(2, 0, 0) D1",
                    "detector(3, 0, 0) D2",
                    "detector(4, 0, 0) D3",
                ])),
                {(0, 1, 2): 0.5, (0, 1, 2, 3): 0.5}
            ],
            [
                stim.DetectorErrorModel("\n".join([
                    "error(0.5) D0",
                    "error(0.5) D0 D1 D2 D3",
                    "detector(1, 0, 0) D0",
                    "detector(2, 0, 0) D1",
                    "detector(3, 0, 0) D2",
                    "detector(4, 0, 0) D3",
                ])),
                {(0,): 0.5, (0, 1, 2, 3): 0.5}
            ]
        ]
    )
    def test_create_dem_from_pij_creates_correct_dem_for_hypergraph(self, dem, pij_data):
        pij_data = {frozenset(x): p for x, p in pij_data.items()}
        hyper_graph, logicals = dem_to_hypergraph_and_logicals(dem)
        b_dem = create_dem_from_pij(pij_data, hyper_graph, logicals)
        assert set(b_dem) == set(dem)

    @pytest.mark.parametrize(
        "dem, expectation_data, expected_pij_data, min_prob",
        [
            [
                stim.DetectorErrorModel("\n".join(
                    ["error(0.1) D0", "error(0.2) D1", "error(0.5) D0 D1", "detector(1, 0, 0) D0", "detector(2,0,0) D1"])),
                {(0,): 0.1, (1,): 0.2, (0, 1): 0.5},
                {(0,): 0.0, (0, 1): 0.27639320225002106, (1,): 0.0},
                0.0,
            ],
            [
                stim.DetectorErrorModel("\n".join(
                    ["error(0.1) D0", "error(0.2) D1", "error(0.5) D0 D1", "detector(1, 0, 0) D0", "detector(2,0,0) D1"])),
                {(0,): 0.1, (1,): 0.2, (0, 1): 0.5},
                {(0,): -0.394427190999916, (0, 1): 0.27639320225002106, (1,): -0.17082039324993697},
                -99.0,
            ],
            [
                stim.DetectorErrorModel("\n".join(
                    ["error(0.1) D0", "error(0.2) D1", "error(0.5) D0 D1", "detector(1, 0, 0) D0", "detector(2,0,0) D1"])),
                {(0,): 0.1, (1,): 0.2, (0, 1): 0.5},
                {(0,): 1.0, (0, 1): 1.0, (1,): 1.0},
                1.0,
            ]
        ]
    )
    def test_calculate_pij_values_replaces_values_below_threshold(self, dem, expectation_data, expected_pij_data, min_prob):
        expectation_data = {frozenset(x): p for x, p in expectation_data.items()}
        expected_pij_data = {frozenset(x): p for x, p in expected_pij_data.items()}
        graph, _ = dem_to_decoding_graph_and_logicals(dem)
        pij_data = dict(sorted(calculate_pij_values(
            expectation_data, graph, min_prob=min_prob).items()))
        assert pij_data == expected_pij_data

    def test_calculate_pij_values_raises_value_error_if_max_degree_above_4(self):
        with pytest.raises(NotImplementedError, match=r".* not a valid degree, must be between 2-4 inclusive."):
            calculate_pij_values({}, max_degree=5)

    @pytest.mark.parametrize(
        "circuit, b8_path, max_degree",
        [
            [
                lf("stim_circuit"),
                lf("detection_events"),
                2,
            ],
            [
                lf("stim_circuit"),
                lf("detection_events"),
                3,
            ]
        ]
    )
    def test_calculate_pij_values_calculates_does_not_calculate_edges_with_degree_above_max_degree(self, circuit, b8_path, max_degree):
        dem = circuit.detector_error_model()
        hyper_graph, _ = dem_to_hypergraph_and_logicals(dem)
        samples = list(b8_to_syndromes(b8_path, len(hyper_graph.nodes)))
        exp_data = generate_expectation_data(samples, max_degree=max_degree+1)
        pij_values = calculate_pij_values(exp_data, hyper_graph, max_degree=max_degree)
        edge_count = 0
        for e in hyper_graph.edges:
            if len(e) <= max_degree:
                edge_count += 1
        assert len(pij_values) == edge_count

    @pytest.mark.parametrize(
        "pij1, pij2",
        [
            [
                {},
                {},
            ],
            [
                {(0, 1): 0.1111, },
                {(0, 1): 0.2222},
            ],
            [
                {(0, 1): 0.1111, },
                {(1, 0): 0.2222},
            ],
            [
                {(0,): 0.5, (0, 1): 0.1},
                {(0, 1): 0.1, (0,): 0.5, },
            ],
            [
                {(0,): 0.5, (0, 1): 0.1, (2,): 0.0},
                {(2,): 0.6, (1, 0): 0.1, (0,): 0.5, },
            ],
        ]
    )
    def test_pijs_contain_same_edges_returns_true_if_edges_identical(self, pij1, pij2):
        pij1 = {frozenset(x): p for x, p in pij1.items()}
        pij2 = {frozenset(x): p for x, p in pij2.items()}
        first_diff, second_diff = pijs_edge_diff(pij1, pij2)
        assert first_diff == set() or second_diff == set()

    @pytest.mark.parametrize(
        "pij1, pij2",
        [
            [
                {},
                {(0,): 0.1},
            ],
            [
                {(1,): 0.2},
                {(0,): 0.1},
            ],
            [
                {(0, 1): 0.1, (1,): 0.5},
                {(0,): 0.1, (1,): 0.2},
            ],
        ]
    )
    def test_pijs_contain_same_edges_returns_false_if_missing_edges(self, pij1, pij2):
        pij1 = {frozenset(x): p for x, p in pij1.items()}
        pij2 = {frozenset(x): p for x, p in pij2.items()}
        first_diff, second_diff = pijs_edge_diff(pij1, pij2)
        assert first_diff != set() or second_diff != set()

    @pytest.mark.parametrize(
        "pij1, pij2",
        [
            [
                {},
                {(0,): 0.1},
            ],
            [
                {(1,): 0.2},
                {(0,): 0.1},
            ],
            [
                {(0, 1): 0.1, (1,): 0.5},
                {(0,): 0.1, (1,): 0.2},
            ],
        ]
    )
    def test_pijs_contain_same_edges_returns_symmetric_diff_if_edges_not_identical(self, pij1, pij2):
        pij1 = {frozenset(x): p for x, p in pij1.items()}
        pij2 = {frozenset(x): p for x, p in pij2.items()}
        first_diff, second_diff = pijs_edge_diff(pij1, pij2)
        assert first_diff != set() or second_diff != set()

    @pytest.mark.parametrize(
        "pij1, pij2",
        [
            [
                {},
                {},
            ],
            [
                {(0,): 0.1},
                {(0,): 0.1},
            ],
            [
                {(0,): 0.1, (1,): 0.5},
                {(0,): 0.1, (1,): 0.5},
            ],
        ]
    )
    def test_pij_edges_max_diff_returns_zero_if_edge_probs_identical(self, pij1, pij2):
        pij1 = {frozenset(x): p for x, p in pij1.items()}
        pij2 = {frozenset(x): p for x, p in pij2.items()}
        assert pij_edges_max_diff(pij1, pij2) == 0.0

    @pytest.mark.parametrize(
        "pij1, pij2, max_diff",
        [
            [
                {(0,): 0.1},
                {(0,): 0.2},
                0.1,
            ],
            [
                {(0,): 0.1, (1,): 0.1},
                {(0,): 0.2, (1,): 0.5},
                0.4,
            ],
        ]
    )
    def test_pij_edges_max_diff_returns_correct_max_diff_for_identical_edges(self, pij1, pij2, max_diff):
        pij1 = {frozenset(x): p for x, p in pij1.items()}
        pij2 = {frozenset(x): p for x, p in pij2.items()}
        assert max_diff == pij_edges_max_diff(pij1, pij2)

    @pytest.mark.parametrize(
        "pij1, pij2",
        [
            [
                {},
                {(0,): 0.1},
            ],
            [
                {(1,): 0.2},
                {(0,): 0.1},
            ],
            [
                {(0, 1): 0.1, (1,): 0.5},
                {(0,): 0.1, (1,): 0.2},
            ],
        ]
    )
    def test_pij_edges_raises_value_error_if_edges_not_identical(self, pij1, pij2):
        pij1 = {frozenset(x): p for x, p in pij1.items()}
        pij2 = {frozenset(x): p for x, p in pij2.items()}
        with pytest.raises(ValueError, match=r"Pij matrices do not contain identical edges so cannot compare for maximum difference. Diff: .*"):
            pij_edges_max_diff(pij1, pij2)

    @pytest.mark.parametrize(
        "dem, pij",
        [
            [
                stim.DetectorErrorModel(),
                {},
            ],
            [
                stim.DetectorErrorModel("\n".join(["error(0.1) D0", "error(0.2) D1"])),
                {(0,): 0.1, (1,): 0.1},
            ],
            [
                stim.DetectorErrorModel(
                    "\n".join(["error(0.1) D0", "error(0.2) D1", "error(0.2) D0 D1"])),
                {(0,): 0.1, (1,): 0.1, (0, 1): 0.2},
            ],
        ]
    )
    def test_pij_and_dem_contain_same_edges_returns_true_if_dem_and_pij_contain_same_edges(self, dem, pij):
        pij = {frozenset(x): p for x, p in pij.items()}
        first_diff, second_diff = pij_and_dem_edge_diff(dem, pij)
        assert first_diff == set() or second_diff == set()

    @pytest.mark.parametrize(
        "dem, pij",
        [
            [
                stim.DetectorErrorModel(),
                {(0,): 0.3},
            ],
            [
                stim.DetectorErrorModel("\n".join(["error(0.1) D1",])),
                {(0,): 0.1, },
            ],
            [
                stim.DetectorErrorModel("\n".join(["error(0.1) D0", "error(0.2) D1",])),
                {(0,): 0.1, (2,): 0.1, },
            ],
            [
                stim.DetectorErrorModel("\n".join(["error(0.1) D0 D1",])),
                {(0,): 0.1, (1,): 0.1, },
            ],
        ]
    )
    def test_pij_and_dem_contain_same_edges_returns_false_if_dem_and_pij_contain_difference_edges(self, dem, pij):
        pij = {frozenset(x): p for x, p in pij.items()}
        first_diff, second_diff = pij_and_dem_edge_diff(dem, pij)
        assert first_diff != set() or second_diff != set()

    @pytest.mark.parametrize(
        "dem, pij, set_diff",
        [
            [
                stim.DetectorErrorModel(),
                {(0,): 0.3},
                (set(), {frozenset((0,))}),
            ],
            [
                stim.DetectorErrorModel("\n".join(["error(0.1) D1",])),
                {(0,): 0.1, },
                ({frozenset((1,))}, {frozenset((0,))}),
            ],
            [
                stim.DetectorErrorModel("\n".join(["error(0.1) D0", "error(0.2) D1",])),
                {(0,): 0.1, (2,): 0.1, },
                ({frozenset((1,))}, {frozenset((2,))}),
            ],
            [
                stim.DetectorErrorModel("\n".join(["error(0.1) D0 D1",])),
                {(0,): 0.1, (1,): 0.1, },
                ({frozenset((0, 1))}, {frozenset((0,)), frozenset((1,))}),
            ],
        ]
    )
    def test_pij_and_dem_contain_same_edges_returns_symmetric_diff_if_dem_pij_edges_differ(self, dem, pij, set_diff):
        pij = {frozenset(x): p for x, p in pij.items()}
        assert pij_and_dem_edge_diff(dem, pij) == set_diff

    @pytest.mark.parametrize(
        "dem, pij",
        [
            [
                stim.DetectorErrorModel("\n".join(["error(0.1) D0 D1",])),
                {(0, 1): 0.2},
            ],
            [
                stim.DetectorErrorModel("\n".join(["error(0.1) D0 D1 D2",])),
                {(0, 1, 2): 0.2},
            ],
            [
                stim.DetectorErrorModel(
                    "\n".join(["error(0.1) D0", "error(0.2) D1", "error(0.2) D0 D1 D2"])),
                {(0,): 0.1, (1,): 0.1, (0, 1, 2): 0.2},
            ],
            [
                stim.DetectorErrorModel("\n".join(
                    ["error(0.1) D0", "error(0.2) D1", "error(0.2) D0 D1", "error(0.2) D0 D1 D2"])),
                {(0,): 0.1, (1,): 0.1, (0, 1): 0.5, (0, 1, 2): 0.2},
            ],
        ]
    )
    def test_pij_and_dem_contain_same_edges_returns_true_if_dem_and_pij_contain_same_edges_for_hypergraph(self, dem, pij):
        pij = {frozenset(x): p for x, p in pij.items()}
        first_diff, second_diff = pij_and_dem_edge_diff(dem, pij, is_hypergraph=True)
        assert first_diff == set() or second_diff == set()

    @pytest.mark.parametrize(
        "dem, pij",
        [
            [
                stim.DetectorErrorModel(),
                {(0, 2): 0.2},
            ],
            [
                stim.DetectorErrorModel("\n".join(["error(0.1) D0 D1",])),
                {},
            ],
            [
                stim.DetectorErrorModel("\n".join(["error(0.1) D0 D1",])),
                {(0, 2): 0.2},
            ],
            [
                stim.DetectorErrorModel("\n".join(["error(0.1) D0 D1 D2",])),
                {(0, 1, 3): 0.2},
            ],
            [
                stim.DetectorErrorModel(
                    "\n".join(["error(0.1) D0", "error(0.2) D1", "error(0.2) D0 D1 D2"])),
                {(0,): 0.1, (3,): 0.1, (0, 1, 2): 0.2},
            ],
            [
                stim.DetectorErrorModel("\n".join(
                    ["error(0.1) D0", "error(0.2) D1", "error(0.2) D0 D1", "error(0.2) D0 D1 D2"])),
                {(0,): 0.1, (6,): 0.1, (0, 1): 0.5, (0, 1, 2): 0.2},
            ],
        ]
    )
    def test_pij_and_dem_contain_same_edges_returns_false_if_dem_and_pij_contain_different_edges_for_hypergraph(self, dem, pij):
        pij = {frozenset(x): p for x, p in pij.items()}
        first_diff, second_diff = pij_and_dem_edge_diff(dem, pij, is_hypergraph=True)
        assert first_diff != set() or second_diff != set()

    @pytest.mark.parametrize(
        "dem, pij, set_diff",
        [
            [
                stim.DetectorErrorModel(),
                {(0, 1, 2): 0.3},
                (set(), {frozenset((0, 1, 2))}),
            ],
            [
                stim.DetectorErrorModel("\n".join(["error(0.1) D0 D1 D2",])),
                {(0, 1, 3): 0.1, },
                ({frozenset((0, 1, 2))}, {frozenset((0, 1, 3))}),
            ],
            [
                stim.DetectorErrorModel(
                    "\n".join(["error(0.1) D0 D1 D2", "error(0.2) D1",])),
                {(1,): 0.1, (0, 1, 3,): 0.1, },
                ({frozenset((0, 1, 2,))}, {frozenset((0, 1, 3,))}),
            ],
        ]
    )
    def test_pij_and_dem_contain_same_edges_returns_symmetric_diff_if_dem_pij_edges_differ_for_hypergraphs(self, dem, pij, set_diff):
        pij = {frozenset(x): p for x, p in pij.items()}
        assert pij_and_dem_edge_diff(dem, pij, is_hypergraph=True) == set_diff

    @pytest.mark.parametrize(
        "dem, pij, max_diff",
        [
            [
                stim.DetectorErrorModel(),
                {},
                0.0,
            ],
            [
                stim.DetectorErrorModel("\n".join(["error(0.1) D0 D1",])),
                {(0, 1): 0.2},
                0.1,
            ],
            [
                stim.DetectorErrorModel("\n".join(["error(0.1) D0 D2",])),
                {(0, 2): 0.2},
                0.1,
            ],
            [
                stim.DetectorErrorModel(
                    "\n".join(["error(0.1) D0", "error(0.2) D1", "error(0.2) D0 D1"])),
                {(0,): 0.1, (1,): 0.1, (0, 1): 0.4},
                0.2,
            ],
            [
                stim.DetectorErrorModel(
                    "\n".join(["error(0.1) D0", "error(0.2) D1", "error(0.2) D0 D1", "error(0.2) D1 D2"])),
                {(0,): 0.1, (1,): 0.1, (0, 1): 0.5, (1, 2): 0.2},
                0.3,
            ],
        ]
    )
    def test_dem_and_pij_edges_max_diff_returns_correct_max_diff(self, dem, pij, max_diff):
        pij = {frozenset(x): p for x, p in pij.items()}
        assert dem_and_pij_edges_max_diff(dem, pij) == max_diff

    @pytest.mark.parametrize(
        "dem, pij, max_diff",
        [
            [
                stim.DetectorErrorModel(),
                {},
                0.0,
            ],
            [
                stim.DetectorErrorModel("\n".join(["error(0.1) D0 D1 D2",])),
                {(0, 1, 2): 0.2},
                0.1,
            ],
            [
                stim.DetectorErrorModel("\n".join(["error(0.1) D0 D2",])),
                {(0, 2): 0.2},
                0.1,
            ],
            [
                stim.DetectorErrorModel(
                    "\n".join(["error(0.1) D0", "error(0.2) D1", "error(0.2) D0 D1 D2"])),
                {(0,): 0.1, (1,): 0.1, (0, 1, 2): 0.4},
                0.2,
            ],
            [
                stim.DetectorErrorModel("\n".join(
                    ["error(0.1) D0", "error(0.2) D1", "error(0.2) D0 D1", "error(0.2) D1 D2 D3"])),
                {(0,): 0.1, (1,): 0.1, (0, 1): 0.5, (1, 2, 3): 0.2},
                0.3,
            ],
        ]
    )
    def test_dem_and_pij_edges_max_diff_returns_correct_max_diff_for_hypergraphs(self, dem, pij, max_diff):
        pij = {frozenset(x): p for x, p in pij.items()}
        assert dem_and_pij_edges_max_diff(dem, pij, is_hypergraph=True) == max_diff

    @pytest.mark.parametrize(
        "dem, pij",
        [
            [
                stim.DetectorErrorModel(),
                {(0, 2): 0.2},
            ],
            [
                stim.DetectorErrorModel("\n".join(["error(0.1) D0 D1",])),
                {},
            ],
            [
                stim.DetectorErrorModel("\n".join(["error(0.1) D0 D1",])),
                {(0, 2): 0.2},
            ],
            [
                stim.DetectorErrorModel("\n".join(["error(0.1) D0 D5",])),
                {(0, 1): 0.2},
            ],
            [
                stim.DetectorErrorModel(
                    "\n".join(["error(0.1) D3", "error(0.2) D1", "error(0.2) D3 D1"])),
                {(0,): 0.1, (1,): 0.1, (1, 2): 0.2},
            ],
            [
                stim.DetectorErrorModel(
                    "\n".join(["error(0.1) D0", "error(0.2) D1", "error(0.2) D0 D1", "error(0.2) D1 D2"])),
                {(1,): 0.1, (0, 1): 0.5, (1, 2): 0.2},
            ],
        ]
    )
    def test_dem_and_pij_edges_max_diff_raises_value_error_if_do_not_contain_same_edges(self, dem, pij):
        pij = {frozenset(x): p for x, p in pij.items()}
        with pytest.raises(ValueError, match=r"Pij matrices do not contain identical edges so cannot compare for maximum difference. Diff: .*"):
            dem_and_pij_edges_max_diff(dem, pij)

    @pytest.mark.parametrize(
        "dem, pij",
        [
            [
                stim.DetectorErrorModel("error(0.1) D0 D1"),
                {(0, 1): 0.1},
            ],
            [
                stim.DetectorErrorModel(
                    "\n".join(["error(0.1) D0", "error(0.1) D0 D1",])),
                {(0,): 0.1, (0, 1): 0.1},
            ]
        ]
    )
    def test_pij_and_dem_edge_diff_gives_correct_answer_when_no_boundary(self, dem, pij):
        pij = {frozenset(x): p for x, p in pij.items()}
        with mock.patch("deltakit_core.decoding_graphs.dem_to_decoding_graph_and_logicals", dem_to_hypergraph_and_logicals):
            first_diff, second_diff = pij_and_dem_edge_diff(
                dem, pij, is_hypergraph=False)
        assert len(first_diff) == 0 and len(second_diff) == 0

    @pytest.mark.parametrize(
        "dem, pij, expected_max_diff",
        [
            [
                stim.DetectorErrorModel("\n".join(["error(0.1) D0 D1",])),
                {(0, 1): 0.2},
                0.1,
            ],
            [
                stim.DetectorErrorModel(
                    "\n".join(["error(0.15) D0", "error(0.1) D0 D1",])),
                {(0,): 0.1, (0, 1): 0.2},
                0.1,
            ]
        ]
    )
    def test_dem_and_pij_edges_max_diff_gives_correct_answer_when_no_boundary(self, dem, pij, expected_max_diff):
        pij = {frozenset(x): p for x, p in pij.items()}
        with mock.patch("deltakit_core.decoding_graphs.dem_to_decoding_graph_and_logicals", dem_to_hypergraph_and_logicals):
            max_diff = dem_and_pij_edges_max_diff(dem, pij, is_hypergraph=False)
        assert max_diff == expected_max_diff

    @pytest.mark.parametrize(
        "exp_data, noise_floor_dem, exp_pij_values",
        [
            [
                {(0,): 0.0, (1,): 0.0, (0, 1): 0.0},
                stim.DetectorErrorModel("\n".join(["error(0.05) D0",
                                                   "error(0.06) D1",
                                                   "error(0.2) D0 D1",
                                                   "detector(1,0,0) D0",
                                                   "detector(2,0,0) D1",])),
                {(0,): 0.05, (1,): 0.06, (0, 1): 0.2},
            ],
            [
                {(0,): 0.2, (1,): 0.2, (0, 1): 0.25},
                stim.DetectorErrorModel("\n".join(["error(0.5) D0",
                                                   "error(0.6) D1",
                                                   "error(0.2) D0 D1",
                                                   "detector(1,0,0) D0",
                                                   "detector(2,0,0) D1",])),
                {(0,): 0.5, (1,): 0.6, (0, 1): 0.22613872124741696},
            ],
            [
                {(0,): 0.2, (1,): 0.2, (0, 1): 0.05},
                stim.DetectorErrorModel("\n".join(["error(0.5) D0",
                                                   "error(0.6) D1",
                                                   "error(0.2) D0 D1",
                                                   "detector(1,0,0) D0",
                                                   "detector(2,0,0) D1",])),
                {(0,): 0.5, (1,): 0.6, (0, 1): 0.2},
            ],
        ]
    )
    def test_calculate_pij_values_floors_values_by_graph(self, exp_data, noise_floor_dem, exp_pij_values):
        exp_data = {frozenset(x): p for x, p in exp_data.items()}
        exp_pij_values = {frozenset(x): p for x, p in exp_pij_values.items()}
        graph, _ = dem_to_decoding_graph_and_logicals(noise_floor_dem)
        pij_data = calculate_pij_values(exp_data, noise_floor_graph=graph)
        assert pij_data == exp_pij_values

    @pytest.mark.parametrize(
        "exp_data, noise_floor_dem, exp_pij_values",
        [
            [
                {(0,): 0.0, (1,): 0.0, (0, 1, 2): 0.0},
                stim.DetectorErrorModel("\n".join(["error(0.05) D0",
                                                   "error(0.06) D1",
                                                   "error(0.2) D0 D1 D2",
                                                   "detector(1,0,0) D0",
                                                   "detector(2,0,0) D1",
                                                   "detector(3,0,0) D2",])),
                {(0,): 0.05, (1,): 0.06, (0, 1, 2): 0.2},
            ],
            [
                {(0,): 0.2, (1,): 0.2, (0, 1): 0.1, (0, 2): 0.1, (1, 2): 0.1, (0, 1, 2): 0.02},
                stim.DetectorErrorModel("\n".join(["error(0.5) D0",
                                                   "error(0.6) D1",
                                                   "error(0.2) D0 D1 D2",
                                                   "detector(1,0,0) D0",
                                                   "detector(2,0,0) D1",
                                                   "detector(3,0,0) D2",])),
                {(0,): 0.5, (1,): 0.6, (0, 1, 2): 0.2, (0, 1): -0.14549722436790286, (0, 2): -0.14549722436790286, (1, 2): -0.14549722436790286},
            ],
            [
                {(0,): 0.2, (1,): 0.2, (0, 1): 0.1, (0, 2): 0.1, (1, 2): 0.1, (0, 1, 2): 0.02},
                stim.DetectorErrorModel("\n".join(["error(0.5) D0",
                                                   "error(0.6) D1",
                                                   "error(0.001) D0 D1",
                                                   "error(0.2) D0 D1 D2",
                                                   "detector(1,0,0) D0",
                                                   "detector(2,0,0) D1",
                                                   "detector(3,0,0) D2",])),
                {(0,): 0.5, (1,): 0.6, (0, 1, 2): 0.2, (0, 1): 0.001, (0, 2): -0.14549722436790286, (1, 2): -0.14549722436790286},
            ],
            [
                {(0,): 0.2, (1,): 0.2, (0, 1): 0.1, (0, 2): 0.1, (1, 2): 0.1, (0, 1, 2): 0.02},
                stim.DetectorErrorModel("\n".join(["error(0.5) D0",
                                                   "error(0.6) D1",
                                                   "error(0.001) D0 D1",
                                                   "error(0.01) D0 D2",
                                                   "error(0.99) D1 D2",
                                                   "error(0.2) D0 D1 D2",
                                                   "detector(1,0,0) D0",
                                                   "detector(2,0,0) D1",
                                                   "detector(3,0,0) D2",])),
                {(0,): 0.5, (1,): 1.0112265347020573, (0, 1, 2): 0.2, (0, 1): 0.001, (0, 2): 0.01, (1, 2): 0.99},
            ],
        ]
    )
    def test_calculate_pij_values_floors_values_by_hypergraph(self, exp_data, noise_floor_dem, exp_pij_values):
        exp_data = {frozenset(x): p for x, p in exp_data.items()}
        exp_pij_values = {frozenset(x): p for x, p in exp_pij_values.items()}
        graph, _ = dem_to_hypergraph_and_logicals(noise_floor_dem)
        pij_data = calculate_pij_values(exp_data, noise_floor_graph=graph, max_degree=3)
        assert pij_data == exp_pij_values

    @pytest.mark.parametrize(
        "exp_data, noise_floor_dem, exp_pij_values",
        [
            [
                {(0,): 0.0, (1,): 0.0, (0, 1): 0.0},
                stim.DetectorErrorModel("\n".join(["error(0.05) D0",
                                                   "error(0.06) D1",
                                                   "detector(1,0,0) D0",
                                                   "detector(2,0,0) D1",])),
                {(0,): 0.05, (1,): 0.06, (0, 1): 0.01},
            ],
            [
                {(0,): 0.0, (1,): 0.0, (0, 1): 0.0},
                stim.DetectorErrorModel("\n".join(["error(0.05) D0",
                                                   "error(0.1) D0 D1",
                                                   "detector(1,0,0) D0",
                                                   "detector(2,0,0) D1",])),
                {(0,): 0.05, (1,): 0.01, (0, 1): 0.1},
            ],
        ]
    )
    def test_calculate_pij_values_floors_values_by_min_prob_when_edge_not_present(self, exp_data, noise_floor_dem, exp_pij_values):
        exp_data = {frozenset(x): p for x, p in exp_data.items()}
        exp_pij_values = {frozenset(x): p for x, p in exp_pij_values.items()}
        graph, _ = dem_to_hypergraph_and_logicals(noise_floor_dem)
        pij_data = calculate_pij_values(exp_data, noise_floor_graph=graph, min_prob=0.01)
        assert pij_data == exp_pij_values

    @pytest.mark.parametrize(
        "exp_data, noise_floor_dem, exp_pij_values",
        [
            [
                {(0,): 0.0, (1,): 0.0, (0, 1): 0.0},
                stim.DetectorErrorModel("\n".join(["error(0.05) D0",
                                                   "error(0.06) D1",
                                                   "detector(1,0,0) D0",
                                                   "detector(2,0,0) D1",])),
                {(0,): 0.05, (1,): 0.06, (0, 1): 0.0},
            ],
            [
                {(0,): 0.0, (1,): 0.0, (0, 1): 0.0},
                stim.DetectorErrorModel("\n".join(["error(0.05) D0",
                                                   "error(0.1) D0 D1",
                                                   "detector(1,0,0) D0",
                                                   "detector(2,0,0) D1",])),
                {(0,): 0.05, (1,): -0.125, (0, 1): 0.1},
            ],
        ]
    )
    def test_calculate_pij_values_does_not_floor_when_edge_not_present_and_min_prob_not_specified(self, exp_data, noise_floor_dem, exp_pij_values):
        exp_data = {frozenset(x): p for x, p in exp_data.items()}
        exp_pij_values = {frozenset(x): p for x, p in exp_pij_values.items()}
        graph, _ = dem_to_hypergraph_and_logicals(noise_floor_dem)
        pij_data = calculate_pij_values(exp_data, noise_floor_graph=graph)
        assert pij_data == exp_pij_values

    @pytest.mark.parametrize(
        "exp_data, noise_floor_dem, exp_pij_values",
        [
            [
                {(0,): 0.0, (1,): 0.0, (0, 1, 2): 0.0},
                stim.DetectorErrorModel("\n".join(["error(0.05) D0",
                                                   "error(0.06) D1",
                                                   "detector(1,0,0) D0",
                                                   "detector(2,0,0) D1",
                                                   "detector(3,0,0) D2",])),
                {(0,): 0.05, (1,): 0.06, (0, 1, 2): 0.01},
            ],
            [
                {(0,): 0.0, (1,): 0.0, (0, 1, 2): 0.0},
                stim.DetectorErrorModel("\n".join(["error(0.05) D0",
                                                   "error(0.2) D0 D1 D2",
                                                   "detector(1,0,0) D0",
                                                   "detector(2,0,0) D1",
                                                   "detector(3,0,0) D2",])),
                {(0,): 0.05, (1,): 0.01, (0, 1, 2): 0.2},
            ],
        ]
    )
    def test_calculate_pij_values_floors_values_by_min_prob_when_hyperedge_not_present(self, exp_data, noise_floor_dem, exp_pij_values):
        exp_data = {frozenset(x): p for x, p in exp_data.items()}
        exp_pij_values = {frozenset(x): p for x, p in exp_pij_values.items()}
        graph, _ = dem_to_hypergraph_and_logicals(noise_floor_dem)
        pij_data = calculate_pij_values(
            exp_data, noise_floor_graph=graph, max_degree=3, min_prob=0.01)
        assert pij_data == exp_pij_values

    @pytest.mark.parametrize(
        "exp_data, noise_floor_dem, exp_pij_values",
        [
            [
                {(0,): 0.0, (1,): 0.0, (0, 1, 2): 0.0},
                stim.DetectorErrorModel("\n".join(["error(0.05) D0",
                                                   "error(0.06) D1",
                                                   "detector(1,0,0) D0",
                                                   "detector(2,0,0) D1",])),
                {(0,): 0.05, (1,): 0.06, (0, 1, 2): 0.00},
            ],
            [
                {(0,): 0.0, (1,): 0.0, (0, 1, 2): 0.0},
                stim.DetectorErrorModel("\n".join(["error(0.05) D0",
                                                   "error(0.1) D0 D1 D2",
                                                   "detector(1,0,0) D0",
                                                   "detector(2,0,0) D1",])),
                {(0,): 0.05, (1,): -0.125, (0, 1, 2): 0.1},
            ],
        ]
    )
    def test_calculate_pij_values_does_not_floor_when_hyperedge_not_present_and_min_prob_not_specified(self, exp_data, noise_floor_dem, exp_pij_values):
        exp_data = {frozenset(x): p for x, p in exp_data.items()}
        exp_pij_values = {frozenset(x): p for x, p in exp_pij_values.items()}
        graph, _ = dem_to_hypergraph_and_logicals(noise_floor_dem)
        pij_data = calculate_pij_values(exp_data, noise_floor_graph=graph, max_degree=3)
        assert pij_data == exp_pij_values
